(ns juy.match
  (:require [rewrite-clj.zip :as z]
            [hara.common.checks :refer [hash-map?]]
            [juy.match.template :refer [match-template]]))

(defrecord Matcher [fn]
  clojure.lang.IFn
  (invoke [this zloc]
    ((:fn this) zloc)))

(defn matcher? [x]
  (instance? Matcher x))

(defn matches? [zloc template]
  (cond (fn? template) (template (z/sexpr zloc))
        (matcher? template) ((:fn template) zloc)
        (list? template) (match-template (z/sexpr zloc) template)
        :else (= template (z/sexpr zloc))))

(defn p-symbol [template]
  (Matcher. (fn [zloc]
              (and (-> zloc z/tag (= :list))
                   (-> zloc z/down z/value (= template))))))

(defn p-type [template]
  (Matcher. (fn [zloc]
              (-> zloc z/tag (= template)))))

(defn p-is [template]
  (Matcher. (fn [zloc]
              (-> zloc z/sexpr (= template)))))

(defn p-matches [template]
  (Matcher. (fn [zloc]
              (-> zloc (matches? template)))))

(defn p-left [template]
  (Matcher. (fn [zloc]
              (if zloc
                (-> zloc z/left (matches? template))))))

(declare nested-compile-matcher)

(defn p-right [template]
  (Matcher. (fn [zloc]
              (if zloc
                (-> zloc z/right (matches? (nested-compile-matcher template)))))))

(defn p-contains [template]
  (Matcher. (fn [zloc]
              (if-let [chd (z/down zloc)]
                (->> chd
                     (iterate z/right)
                     (take-while identity)
                     (map #(matches? % template))
                     (some identity))))))

(defn p-and [& matchers]
  (Matcher. (fn [zloc]
              (->> (map #(% zloc) matchers)
                   (every? true?)))))

(defn p-or [& matchers]
  (Matcher. (fn [zloc]
              (->> (map #(% zloc) matchers)
                   (some true?)))))

(defn compile-matcher [template]
  (cond (symbol? template)   (p-symbol template)
        (fn? template)       (p-matches template)
        (list? template)     (p-matches template)
        (vector? template)   (apply p-and (map compile-matcher template))
        (set? template)      (apply p-or (map compile-matcher template))
        (hash-map? template)
        (apply p-and
               (map (fn [[k v]]
                      (condp = k
                        :type     (p-type v)
                        :matches  (p-matches v)
                        :is       (p-is v)
                        :right    (p-right v)
                        :left     (p-left v)
                        :contains (p-contains v)))
                    template))))

(defn nested-compile-matcher [template]
  (let [template (if (and (or (hash-map? template)
                              (set? template)
                              (list? template)
                              (vector? template))
                          (-> (meta template) :- not))
                   (compile-matcher template)
                   template)]))
